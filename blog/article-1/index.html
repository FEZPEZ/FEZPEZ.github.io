<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Isaac Beals</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background: #0066cc url('https://www.transparenttextures.com/patterns/blueprint.png') repeat;
        }
        header {
            background: #111;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
        }
        .logo { font-weight: bold; font-size: 20px; }
        nav a {
            color: white;
            text-decoration: none;
            margin-left: 20px;
            font-weight: bold;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            color: white;
        }
        #content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 600px;
            text-align: center;
            color: black;
        }
        #content h1 { font-size: 40px; margin-bottom: 20px; }
        #content p { font-size: 22px; }
        canvas#canvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
<header id="siteHeader">
    <div class="logo"><span>Isaac's Thing</span></div>
    <nav>
        <a href="#"><span>ROADTRIP</span></a>
        <a href="#"><span>Articles</span></a>
        <a href="#"><span>About</span></a>
    </nav>
</header>

<div id="content">
    <h1><span>Exploding Demo</span></h1>
    <p>
    <span>This is a paragraph of text, split across multiple lines.
    When you click the button, every single letter will break apart
    and scatter like an explosion.</span>
    </p>
</div>

<div id="controls">
    <button id="mainBtn" style="background:red">BLAMMO</button>
</div>

<canvas id="canvas"></canvas>

<script>
    const EXPLOSION_FORCE = 0.05;
    const BLACK_HOLE_FORCE = 0.0015;
    const BLACK_HOLE_RADIUS = 50;

    const EXPLODE_BUTTON_TEXT_CONTENT = "BLAMMO";
    const CLEAN_BUTTON_TEXT_CONTENT = "CLEAN UP";
    const RESET_BUTTON_TEXT_CONTENT = "RESET";

    const { Engine, World, Bodies, Body, Composite } = Matter;

    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let engine, ctx;
    let exploded = false;
    let blackHoleActive = false;
    let state = "explode"; // cycle: explode -> cleanup -> reset

    const siteHeader = document.getElementById('siteHeader');
    const contentDiv = document.getElementById('content');
    const mainBtn = document.getElementById('mainBtn');

    // measure each visible character inside a container
    function measureCharacters(container) {
        const ranges = [];
        const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);

        while (walker.nextNode()) {
            const node = walker.currentNode;
            const text = node.textContent;
            for (let i = 0; i < text.length; i++) {
                const range = document.createRange();
                range.setStart(node, i);
                range.setEnd(node, i + 1);
                const rect = range.getBoundingClientRect();
                if (rect.width && rect.height) {
                    ranges.push({
                        char: text[i],
                        x: rect.left + rect.width/2 + window.scrollX,
                        y: rect.top + rect.height/2 + window.scrollY,
                        font: window.getComputedStyle(node.parentElement).font,
                        color: window.getComputedStyle(node.parentElement).color,
                        sourceEl: node.parentElement
                    });
                }
            }
        }
        return ranges;
    }

    function explode() {
        if (exploded) return;
        exploded = true;

        const positions = [
            ...measureCharacters(siteHeader),
            ...measureCharacters(contentDiv)
        ];

        // hide original text spans
        positions.forEach(p => { if (p.sourceEl) p.sourceEl.style.visibility = "hidden"; });

        engine = Engine.create();
        ctx = canvas.getContext("2d");

        const w = canvas.width, h = canvas.height, t = 50;
        World.add(engine.world, [
            Bodies.rectangle(w/2, -t/2, w, t, { isStatic: true }),
            Bodies.rectangle(w/2, h+t/2, w, t, { isStatic: true }),
            Bodies.rectangle(-t/2, h/2, t, h, { isStatic: true }),
            Bodies.rectangle(w+t/2, h/2, t, h, { isStatic: true })
        ]);

        positions.forEach(pos => {
            if (pos.char.trim() === "") return;
            const body = Bodies.circle(pos.x, pos.y, 8, { restitution: 0.9, label: pos.char });
            body.font = pos.font;
            body.color = pos.color;
            World.add(engine.world, body);

            const dx = body.position.x - w/2;
            const dy = body.position.y - h/2;
            const len = Math.sqrt(dx*dx + dy*dy) || 1;
            Body.applyForce(body, body.position, {
                x: (dx/len) * EXPLOSION_FORCE,
                y: (dy/len) * EXPLOSION_FORCE
            });
        });

        (function update() {
            if (!exploded) return;
            Matter.Engine.update(engine, 1000/60);
            ctx.clearRect(0, 0, w, h);

            if (blackHoleActive) {
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(w/2, h/2, BLACK_HOLE_RADIUS, 0, Math.PI*2);
                ctx.fill();
            }

            const bodies = Composite.allBodies(engine.world);
            for (let i = bodies.length - 1; i >= 0; i--) {
                const b = bodies[i];
                if (b.label && b.label.length === 1) {
                    // black hole pull
                    if (blackHoleActive) {
                        const dx = (w/2 - b.position.x);
                        const dy = (h/2 - b.position.y);
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        Body.applyForce(b, b.position, {
                            x: (dx/dist) * BLACK_HOLE_FORCE,
                            y: (dy/dist) * BLACK_HOLE_FORCE
                        });
                        if (dist < BLACK_HOLE_RADIUS) {
                            Composite.remove(engine.world, b);
                            continue;
                        }
                    }

                    // bounce-snap bounds
                    const r = b.circleRadius || 8;
                    if (b.position.x < r) {
                        Body.setPosition(b, { x: r, y: b.position.y });
                        Body.setVelocity(b, { x: -b.velocity.x, y: b.velocity.y });
                    }
                    if (b.position.x > w - r) {
                        Body.setPosition(b, { x: w - r, y: b.position.y });
                        Body.setVelocity(b, { x: -b.velocity.x, y: b.velocity.y });
                    }
                    if (b.position.y < r) {
                        Body.setPosition(b, { x: b.position.x, y: r });
                        Body.setVelocity(b, { x: b.velocity.x, y: -b.velocity.y });
                    }
                    if (b.position.y > h - r) {
                        Body.setPosition(b, { x: b.position.x, y: h - r });
                        Body.setVelocity(b, { x: b.velocity.x, y: -b.velocity.y });
                    }

                    // draw character
                    ctx.save();
                    ctx.translate(b.position.x, b.position.y);
                    ctx.rotate(b.angle);
                    ctx.fillStyle = b.color || "black";
                    ctx.font = b.font || "22px sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(b.label, 0, 0);
                    ctx.restore();
                }
            }
            requestAnimationFrame(update);
        })();
    }

    function reset() {
        exploded = false;
        blackHoleActive = false;
        state = "explode";
        mainBtn.textContent = EXPLODE_BUTTON_TEXT_CONTENT;
        mainBtn.style.background = "red";
        // show text spans again
        siteHeader.querySelectorAll("span").forEach(s => s.style.visibility = "visible");
        contentDiv.querySelectorAll("span").forEach(s => s.style.visibility = "visible");
        ctx.clearRect(0,0,canvas.width,canvas.height);
        engine = null;
    }

    // button cycle with text + color change
    mainBtn.addEventListener('click', () => {
        if (state === "explode") {
            explode();
            state = "cleanup";
            mainBtn.textContent = CLEAN_BUTTON_TEXT_CONTENT;
            mainBtn.style.background = "black";
        } else if (state === "cleanup") {
            blackHoleActive = true;
            state = "reset";
            mainBtn.textContent = RESET_BUTTON_TEXT_CONTENT;
            mainBtn.style.background = "gray";
        } else if (state === "reset") {
            reset();
        }
    });
</script>
</body>
</html>
